# LiveData/schwab/management/commands/schwab_stream.py

from __future__ import annotations

import asyncio
import json
import logging
import time
from copy import deepcopy
from typing import List, Optional, Dict, Tuple, Set

import redis
from asgiref.sync import sync_to_async
from django.conf import settings
from django.core.management.base import BaseCommand, CommandError

from LiveData.schwab.models import BrokerConnection, SchwabSubscription
from LiveData.schwab.client.streaming import SchwabStreamingProducer
from LiveData.schwab.client.tokens import ensure_valid_access_token

logger = logging.getLogger(__name__)

SCHWAB_SUBSCRIPTION_CHANNEL = "live_data:subscriptions:schwab"


def _parse_csv(value: Optional[str]) -> List[str]:
    if not value:
        return []
    return [item.strip().upper() for item in value.split(",") if item.strip()]


def _group_subscriptions(rows: List[Dict[str, str]]) -> Tuple[List[str], List[str]]:
    """
    Returns (equities_and_indexes, futures)
    Treat INDEX as equity-stream for now.
    """
    equities: List[str] = []
    futures: List[str] = []

    for row in rows:
        sym = (row.get("symbol") or "").strip().upper()
        typ = (row.get("asset_type") or "").strip().upper()
        if not sym:
            continue

        if typ in {"FUTURE", "FUTURES"}:
            futures.append(sym)
        else:
            # EQUITY + INDEX + anything else we want to try on equity L1 feed
            equities.append(sym)

    def _dedupe(xs: List[str]) -> List[str]:
        seen = set()
        out = []
        for x in xs:
            if x in seen:
                continue
            seen.add(x)
            out.append(x)
        return out

    return _dedupe(equities), _dedupe(futures)


class Command(BaseCommand):
    help = "Start Schwab streaming and publish ticks to Redis/WebSocket (instant subscribe via Redis Pub/Sub)"

    def add_arguments(self, parser):
        parser.add_argument("--user-id", type=int, required=True)

        # Optional CLI overrides (still supported)
        parser.add_argument("--equities", type=str, default="")
        parser.add_argument("--futures", type=str, default="")

        # Optional DB filter
        parser.add_argument("--types", type=str, default="", help="Optional DB filter: EQUITY,INDEX,FUTURE")

    def handle(self, *args, **options):
        try:
            from schwab import auth as schwab_auth  # type: ignore
            from schwab.streaming import StreamClient  # type: ignore
        except Exception as exc:
            raise CommandError("schwab-py is not installed. Install with `pip install schwab-py`") from exc

        user_id: int = options["user_id"]

        cli_equities: List[str] = _parse_csv(options.get("equities"))
        cli_futures: List[str] = _parse_csv(options.get("futures"))
        types_filter = set(_parse_csv(options.get("types")))

        connection = (
            BrokerConnection.objects.select_related("user")
            .filter(user_id=user_id, broker=BrokerConnection.BROKER_SCHWAB)
            .first()
        )
        if not connection:
            raise CommandError(f"No Schwab BrokerConnection found for user_id={user_id}")

        # Preflight refresh so we do not start streaming with an about-to-expire token
        connection = ensure_valid_access_token(connection, buffer_seconds=120)

        refresh_from_db_async = sync_to_async(lambda obj: obj.refresh_from_db(), thread_sensitive=True)
        ensure_token_async = sync_to_async(ensure_valid_access_token, thread_sensitive=True)

        api_key = getattr(settings, "SCHWAB_CLIENT_ID", None) or getattr(settings, "SCHWAB_API_KEY", None)
        app_secret = getattr(settings, "SCHWAB_CLIENT_SECRET", None)
        account_id = connection.broker_account_id or None

        if not api_key or not app_secret:
            raise CommandError("SCHWAB_CLIENT_ID and SCHWAB_CLIENT_SECRET must be set in settings/.env")

        if not account_id:
            # Auto-resolve broker_account_id (hashValue) from Schwab if missing
            from LiveData.schwab.client.trader import SchwabTraderAPI

            try:
                api = SchwabTraderAPI(connection.user)
                accounts = api.fetch_accounts() or []
                acct_hash_map = api.fetch_account_numbers_map()

                if not accounts:
                    raise CommandError("No Schwab accounts returned; cannot resolve broker_account_id")

                sec = (accounts[0] or {}).get("securitiesAccount", {}) or {}
                account_number = sec.get("accountNumber") or (accounts[0] or {}).get("accountNumber")

                if not account_number:
                    raise CommandError("Unable to find Schwab accountNumber to resolve hashValue")

                account_id = acct_hash_map.get(str(account_number))
                if not account_id:
                    account_id = api.resolve_account_hash(str(account_number))

                connection.broker_account_id = str(account_id)
                connection.save(update_fields=["broker_account_id", "updated_at"])
            except Exception as exc:
                raise CommandError(f"Auto-resolve broker_account_id failed: {exc}")

        if not account_id:
            raise CommandError("Schwab connection missing broker_account_id; cannot start stream")

        # Token cache kept in-memory so schwab-py callbacks avoid ORM in async loop
        token_state = {
            "creation_timestamp": int(connection.updated_at.timestamp())
            if getattr(connection, "updated_at", None)
            else int(time.time()),
            "token": {
                "access_token": connection.access_token,
                "refresh_token": connection.refresh_token,
                "expires_at": int(connection.access_expires_at or 0),
                "token_type": "Bearer",
            },
        }

        async def _persist_tokens(payload: dict) -> None:
            await refresh_from_db_async(connection)
            connection.access_token = payload.get("access_token") or connection.access_token
            connection.refresh_token = payload.get("refresh_token") or connection.refresh_token
            if payload.get("expires_at") is not None:
                connection.access_expires_at = int(payload.get("expires_at") or 0)
            await sync_to_async(connection.save, thread_sensitive=True)(
                update_fields=["access_token", "refresh_token", "access_expires_at", "updated_at"],
            )

        def _read_token():
            return deepcopy(token_state)

        def _write_token(token_obj):
            payload = token_obj.get("token") if isinstance(token_obj, dict) and "token" in token_obj else token_obj
            if not isinstance(payload, dict):
                payload = {}

            token_state["token"].update(
                {
                    "access_token": payload.get("access_token") or token_state["token"].get("access_token"),
                    "refresh_token": payload.get("refresh_token") or token_state["token"].get("refresh_token"),
                    "expires_at": int(payload.get("expires_at") or token_state["token"].get("expires_at") or 0),
                    "token_type": "Bearer",
                }
            )
            token_state["creation_timestamp"] = int(time.time())
            loop = asyncio.get_running_loop()
            loop.create_task(_persist_tokens(token_state["token"].copy()))

        producer = SchwabStreamingProducer()

        @sync_to_async(thread_sensitive=True)
        def _load_db_subscriptions() -> Tuple[List[str], List[str]]:
            qs = SchwabSubscription.objects.filter(user_id=user_id, enabled=True)
            if types_filter:
                qs = qs.filter(asset_type__in=list(types_filter))
            rows = list(qs.values("symbol", "asset_type"))
            return _group_subscriptions(rows)

        def _redis_client() -> redis.Redis:
            return redis.Redis(
                host=getattr(settings, "REDIS_HOST", "localhost"),
                port=getattr(settings, "REDIS_PORT", 6379),
                db=getattr(settings, "REDIS_DB", 0),
                decode_responses=True,
            )

        async def _run():
            backoff = 2
            max_backoff = 60

            while True:
                try:
                    conn = connection
                    await refresh_from_db_async(conn)
                    conn = await ensure_token_async(conn, buffer_seconds=120)

                    token_state["token"] = {
                        "access_token": conn.access_token,
                        "refresh_token": conn.refresh_token,
                        "expires_at": int(conn.access_expires_at or 0),
                        "token_type": "Bearer",
                    }
                    token_state["creation_timestamp"] = int(conn.updated_at.timestamp()) if getattr(
                        conn, "updated_at", None
                    ) else int(time.time())

                    api_client = schwab_auth.client_from_access_functions(
                        api_key,
                        app_secret,
                        token_read_func=_read_token,
                        token_write_func=_write_token,
                        asyncio=True,
                    )

                    stream_client = StreamClient(api_client, account_id=str(account_id))
                    await stream_client.login()

                    # IMPORTANT: Handlers must be added BEFORE subscribing
                    stream_client.add_level_one_equity_handler(producer.process_message)
                    stream_client.add_level_one_futures_handler(producer.process_message)

                    # Track what we have subscribed to
                    subscribed_equities: Set[str] = set()
                    subscribed_futures: Set[str] = set()

                    async def subscribe_equities(symbols: List[str]):
                        if not symbols:
                            return
                        syms = [s.upper() for s in symbols if s]
                        if not syms:
                            return
                        await stream_client.level_one_equity_subs(syms)
                        subscribed_equities.update(syms)
                        logger.info("Subscribed equities: %s", syms)

                    async def subscribe_futures(symbols: List[str]):
                        if not symbols:
                            return
                        syms = [s.upper() for s in symbols if s]
                        if not syms:
                            return
                        await stream_client.level_one_futures_subs(syms)
                        subscribed_futures.update(syms)
                        logger.info("Subscribed futures: %s", syms)

                    async def unsubscribe_equities(symbols: List[str]):
                        if not symbols:
                            return
                        syms = [s.upper() for s in symbols if s]
                        if not syms:
                            return
                        # schwab-py may or may not support unsubs; call if available
                        fn = getattr(stream_client, "level_one_equity_unsubs", None)
                        if callable(fn):
                            await fn(syms)
                            logger.info("Unsubscribed equities: %s", syms)
                        else:
                            logger.warning("Equity unsubs not supported by StreamClient; ignoring: %s", syms)
                        for s in syms:
                            subscribed_equities.discard(s)

                    async def unsubscribe_futures(symbols: List[str]):
                        if not symbols:
                            return
                        syms = [s.upper() for s in symbols if s]
                        if not syms:
                            return
                        fn = getattr(stream_client, "level_one_futures_unsubs", None)
                        if callable(fn):
                            await fn(syms)
                            logger.info("Unsubscribed futures: %s", syms)
                        else:
                            logger.warning("Futures unsubs not supported by StreamClient; ignoring: %s", syms)
                        for s in syms:
                            subscribed_futures.discard(s)

                    async def initial_subscribe():
                        # CLI overrides win; otherwise load from DB
                        if cli_equities or cli_futures:
                            eq = [s.upper() for s in cli_equities]
                            fu = [s.upper() for s in cli_futures]
                        else:
                            eq, fu = await _load_db_subscriptions()

                        # Subscribe only to new ones
                        add_eq = [s for s in eq if s not in subscribed_equities]
                        add_fu = [s for s in fu if s not in subscribed_futures]
                        if add_eq:
                            await subscribe_equities(add_eq)
                        if add_fu:
                            await subscribe_futures(add_fu)

                        if not (subscribed_equities or subscribed_futures):
                            raise CommandError(
                                "No symbols to stream.\n"
                                "Add enabled SchwabSubscription rows, or pass --equities/--futures."
                            )

                    await initial_subscribe()

                    # --- Redis Pub/Sub listener (instant subscriptions) ---
                    r = _redis_client()
                    pubsub = r.pubsub()
                    pubsub.subscribe(SCHWAB_SUBSCRIPTION_CHANNEL)

                    async def subscription_listener():
                        """
                        Listen for subscription events and apply instantly.
                        Uses a thread hop because redis-py pubsub is blocking/sync.
                        """
                        logger.info("Listening for subscription events on %s", SCHWAB_SUBSCRIPTION_CHANNEL)

                        while True:
                            # Get one message in a worker thread so we don't block the asyncio loop
                            msg = await asyncio.to_thread(pubsub.get_message, True, 1.0)
                            if not msg:
                                continue

                            if msg.get("type") != "message":
                                continue

                            try:
                                payload = json.loads(msg.get("data") or "{}")
                            except Exception:
                                logger.warning("Bad subscription event payload: %s", msg.get("data"))
                                continue

                            # Only handle our user
                            if int(payload.get("user_id") or 0) != int(user_id):
                                continue

                            action = (payload.get("action") or "").lower()
                            symbol = (payload.get("symbol") or "").upper()
                            asset_type = (payload.get("asset_type") or "").upper()

                            if not symbol:
                                continue

                            # Route INDEX like equity stream
                            is_future = asset_type in {"FUTURE", "FUTURES"}
                            is_equity_like = not is_future

                            # If user passed CLI overrides, we still allow instant adds,
                            # but you can lock it down if you want.
                            if action == "subscribe":
                                if is_future:
                                    if symbol not in subscribed_futures:
                                        await subscribe_futures([symbol])
                                else:
                                    if symbol not in subscribed_equities:
                                        await subscribe_equities([symbol])

                            elif action == "unsubscribe":
                                if is_future:
                                    if symbol in subscribed_futures:
                                        await unsubscribe_futures([symbol])
                                else:
                                    if symbol in subscribed_equities:
                                        await unsubscribe_equities([symbol])

                    listener_task = asyncio.create_task(subscription_listener())

                    try:
                        # Main streaming loop
                        while True:
                            await stream_client.handle_message()
                    finally:
                        listener_task.cancel()
                        try:
                            pubsub.close()
                        except Exception:
                            pass

                except asyncio.CancelledError:
                    raise
                except Exception as exc:
                    logger.warning("Schwab stream loop error; reconnecting in %ss: %s", backoff, exc, exc_info=True)
                    await asyncio.sleep(backoff)
                    backoff = min(backoff * 2, max_backoff)

        self.stdout.write(
            self.style.SUCCESS(
                f"Starting Schwab stream user_id={user_id} "
                f"cli_equities={cli_equities or '-'} cli_futures={cli_futures or '-'} "
                f"(instant subscribe channel={SCHWAB_SUBSCRIPTION_CHANNEL})"
            )
        )

        try:
            asyncio.run(_run())
        except KeyboardInterrupt:
            self.stdout.write(self.style.WARNING("Schwab stream stopped (KeyboardInterrupt)"))
